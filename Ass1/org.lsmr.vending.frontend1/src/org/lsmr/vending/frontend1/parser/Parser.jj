options{  BUILD_TOKEN_MANAGER = true;  JAVA_UNICODE_ESCAPE = false;  UNICODE_INPUT = true;  ERROR_REPORTING = false;  COMMON_TOKEN_ACTION = false;  STATIC = false;  DEBUG_TOKEN_MANAGER = false;  DEBUG_PARSER = false;}PARSER_BEGIN(Parser)package org.lsmr.vending.frontend1.parser;import java.util.*;import org.lsmr.vending.frontend1.*;public class Parser {  private boolean debug = false;    public void setDebug(boolean flag) {    debug = flag;  }  public Parser(String s) {    this(new java.io.StringReader(s));  }  public boolean inputIsConsumed()  {    try    {      Token t = token_source.getNextToken();      if (t.kind != ParserConstants.EOF || t.specialToken != null) return false;    }    catch (TokenMgrError e)    {      return false;    }    return true;  }  private IVendingMachineFactory vm = null;  private ArrayList<Deliverable> extraction = new ArrayList<Deliverable>();  private ArrayList<Object> teardown = new ArrayList<Object>();    public void register(IVendingMachineFactory vm) {    this.vm = vm;  }  private boolean checkDelivery(int change, List<String> pops)  {    boolean result = true;    if(extraction == null)      return false;      	for(Object o: extraction)	{	  if(o instanceof Coin)	    change -= ((Coin)o).getValue();   	  else	  {	    String name = ((Pop)o).getName();	    if(!(pops.contains(name))) {	        result = false;	    	if(debug)	    	  System.err.println("Failure: " + name + " has been returned where it should not have been");        }        else          pops.remove(name);	  }	}	if(change != 0) {	  result = false;	  if(debug)   	    System.err.println("Failure: " + change + " != 0");    }    	if(!pops.isEmpty())		for(String s : pops) {		  result = false;		  if(debug)		    System.err.println("Failure: expected to find " + s);		}	return result;  }  private boolean checkTeardown(int change, int payments, List<String> pops) {    boolean result = true;	if(teardown == null || teardown.size() < 2) {	  if(debug)	    System.err.println("Failure: teardown does not contain at least the two integers");	  return false;	}	int unusedValue = 0;	try {	    List<Coin> coins = (List<Coin>)teardown.get(0);	    for(Coin c : coins)	      unusedValue += c.getValue();	}	catch(ClassCastException cce) {	    result = false;		if(debug)	         System.err.println("Failure: unusued change contains a non-Coin object");	}    int paymentValue = 0;	try {	    List<Coin> coins = (List<Coin>)teardown.get(1);	    for(Coin c : coins)	      paymentValue += c.getValue();	}	catch(ClassCastException cce) {	    result = false;		if(debug)    	    System.err.println("Failure: payment coins contains a non-Coin object");	}    if(unusedValue != change) {	    result = false;		if(debug)		    System.err.println("Failure: change expected is " + change + " but was " + unusedValue);    }    if(paymentValue != payments) {	    result = false;		if(debug)		    System.err.println("Failure: payments expected is " + payments + " but was " + paymentValue);    }	      List<Pop> unsoldPops = (List<Pop >)teardown.get(2);	try {    	for(Pop pop : unsoldPops) {	        String name = pop.getName();	        if(!(pops.contains(name))) {	            result = false;	            if(debug)	                System.err.println("Failure: " + name + " has been returned where it should not have been");            }            else                pops.remove(name);	     }    }    catch(ClassCastException cce) {        result = false;		if(debug)    	    System.err.println("Failure: unsold pops contains a non-Pop object");    }    	if(!pops.isEmpty())	    for(String s : pops) {	        result = false;		    if(debug)		        System.err.println("Failure: expected to find " + s);		}	return result;  }  private void announceConstruct(ArrayList<Integer> coinKinds, int selectionButtonCount) {    vm.constructNewVendingMachine(coinKinds, selectionButtonCount);  }	      private void announceConfigure(int vmIndex, ArrayList<String> popNames, ArrayList<Integer> popCosts) {    vm.configureVendingMachine(vmIndex, popNames, popCosts);  }  private void announceCoinLoad(int vmIndex, int coinKindIndex, Coin... coins) {    vm.loadCoins(vmIndex, coinKindIndex, coins);  }  private void announcePopLoad(int vmIndex, int popKindIndex, Pop... pops) {    vm.loadPops(vmIndex, popKindIndex, pops);  }  private void announceUnload(int vmIndex) {    teardown.clear();    teardown.addAll(vm.unloadVendingMachine(vmIndex));  }  private void announceExtract(int vmIndex) {    extraction.clear();    extraction.addAll(vm.extractFromDeliveryChute(vmIndex));  }  private void announcePress(int vmIndex, int index) {    vm.pressButton(vmIndex, index);  }  private void announceInsert(int vmIndex, Coin coin) {    vm.insertCoin(vmIndex, coin);  }}PARSER_END(Parser)SKIP :{  " "| "\t"| "\n"| "\r"| "\f"}/* COMMENTS */MORE :{  < "/**" ~[ "/" ] > { input_stream.backup(1); } : FORMAL_COMMENT| "/*": MULTI_LINE_COMMENT}SKIP :{  < SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? >}< MULTI_LINE_COMMENT, FORMAL_COMMENT >SKIP :{  "*/": DEFAULT}< FORMAL_COMMENT, MULTI_LINE_COMMENT >MORE :{  < ~[ ] >}TOKEN :{  < CONSTRUCT : "construct" >| < CONFIGURE : "configure" >| < EXTRACT : "extract" >| < PRESS : "press" >| < INSERT : "insert" >| < COIN_LOAD : "coin-load" >| < POP_LOAD : "pop-load" >| < UNLOAD : "unload" >| < CHECK_DELIVERY : "CHECK_DELIVERY" >| < CHECK_TEARDOWN : "CHECK_TEARDOWN" >}TOKEN :{  < INTEGER_LITERAL : ("-")? [ "1"-"9" ] ([ "0"-"9" ])* | "0" >|  < STRING_LITERAL:      "\""      (   (~["\"","\\","\n","\r"])        | ("\\"            ( ["n","t","b","r","f","\\","'","\""]            | ["0"-"7"] ( ["0"-"7"] )?            | ["0"-"3"] ["0"-"7"] ["0"-"7"]            )          )      )*      "\""  >}TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < COMMA : "," >| < SEMICOLON : ";" >}void process(String path) :{  boolean res;  int i = 0;}{  {	System.err.println("Script: " + path);  }  ( res = Command()  {    System.err.print("Command #" + i++ + ": ");    if(res)	    System.err.println("PASS");	else	    System.err.println("FAIL");  }  )*  {    System.err.println();  }  < EOF >}boolean Command() :{  boolean res = true;}{(  Construct()| Configure()| Extract()| Press()| Insert()| CoinLoad()| PopLoad()| Unload()| res = CHECK_DELIVERY()| res = CHECK_TEARDOWN()){  return res;}}void Construct() :{  Token ch;  int selectionButtonCount;  ArrayList<Integer> coinKinds = new ArrayList<Integer>();}{  < CONSTRUCT > "(" ch = < INTEGER_LITERAL >  {    coinKinds.add(Integer.parseInt(ch.image));  }  (    "," ch = < INTEGER_LITERAL >    {      coinKinds.add(Integer.parseInt(ch.image));    }  )*  ";"  ch = < INTEGER_LITERAL >  {    selectionButtonCount = Integer.parseInt(ch.image);  }  ")"  {    announceConstruct(coinKinds, selectionButtonCount);  }}void Configure() :{  Token vm, name, cost;  ArrayList<String> names = new ArrayList<String>();  ArrayList<Integer> costs = new ArrayList<Integer>();}{  < CONFIGURE > "(" "[" vm = < INTEGER_LITERAL > "]"    name = < STRING_LITERAL >  "," cost = < INTEGER_LITERAL >  {    names.add(name.image);    costs.add(Integer.parseInt(cost.image));  }  (    ";"       name = < STRING_LITERAL >    "," cost = < INTEGER_LITERAL >    {      names.add(name.image);      costs.add(Integer.parseInt(cost.image));    }  )*  ")"  {    announceConfigure(Integer.parseInt(vm.image), names, costs);  }}void CoinLoad() :{  Token vm, index, coinCount, coinValue;}{  < COIN_LOAD > "(" "[" vm = < INTEGER_LITERAL > "]"  index = < INTEGER_LITERAL >  ";" coinValue = < INTEGER_LITERAL >  "," coinCount = < INTEGER_LITERAL >  ")"    {    int v = Integer.parseInt(coinValue.image);    int c = Integer.parseInt(coinCount.image);    Coin[] coins = new Coin[c];    for(int i = 0, size = c; i < size; i++)    {      coins[i] = new Coin(v);    }    announceCoinLoad(Integer.parseInt(vm.image), Integer.parseInt(index.image), coins);  }}void PopLoad() :{  Token vm, index, popCount, popName;}{  < POP_LOAD > "(" "[" vm = < INTEGER_LITERAL > "]"  index = < INTEGER_LITERAL >  ";" popName = < STRING_LITERAL >  "," popCount = < INTEGER_LITERAL >  ")"    {    int c = Integer.parseInt(popCount.image);    Pop[] pops = new Pop[c];    for(int i = 0, size = c; i < size; i++)    {        pops[i] = new Pop(popName.image);    }    announcePopLoad(Integer.parseInt(vm.image), Integer.parseInt(index.image), pops);  }}boolean CHECK_DELIVERY() :{  Token ch, pop;  int change;  ArrayList<String> pops = new ArrayList<String>();}{  < CHECK_DELIVERY > "("  ch = < INTEGER_LITERAL >  {    change = Integer.parseInt(ch.image);  }  ("," pop = < STRING_LITERAL >  {  	  pops.add(pop.image);  } )*  ")"  {    return checkDelivery(change, pops);  }}boolean CHECK_TEARDOWN() :{  Token ch, pop;  int change, payments;  ArrayList<String> pops = new ArrayList<String>();}{  < CHECK_TEARDOWN > "(" ch = < INTEGER_LITERAL >  {    change = Integer.parseInt(ch.image);  }  ";"   ch = < INTEGER_LITERAL >  {    payments = Integer.parseInt(ch.image);  }    [";" [pop = < STRING_LITERAL >  {  	  pops.add(pop.image);  }    ("," pop = < STRING_LITERAL >  {  	  pops.add(pop.image);  } )*  ]]  ")"  {    return checkTeardown(change, payments, pops);  }}void Extract() :{  Token vm;}{  < EXTRACT > "(" "[" vm = < INTEGER_LITERAL > "]" ")"  {    announceExtract(Integer.parseInt(vm.image));  }}void Press() :{  Token vm, t;}{  < PRESS > "(" "[" vm = < INTEGER_LITERAL > "]" t = < INTEGER_LITERAL >")"  {    announcePress(Integer.parseInt(vm.image), Integer.parseInt(t.image));  }}void Insert() :{  Token vm, t;}{  < INSERT > "(" "[" vm = < INTEGER_LITERAL > "]" t = < INTEGER_LITERAL >")"  {    announceInsert(Integer.parseInt(vm.image), new Coin(Integer.parseInt(t.image)));  }}void Unload() :{  Token vm;}{  < UNLOAD > "(" "[" vm = < INTEGER_LITERAL > "]" ")"  {    announceUnload(Integer.parseInt(vm.image));  }}